<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="xiner">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="xiner">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="xiner">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>xiner</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xiner</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/02/BFC和IFC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xdd">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/BFC和IFC/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-02T17:08:49+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>###BFC 块级格式化上下文</p>
<p>####BFC布局规则：<br>1、内部的Box会在垂直方向，一个接一个地放置；<br>2、Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠；<br>3、每个元素的margin box的左边，与包含块border box的左边相接触；<br>4、BFC的区域不会与float box重叠；<br>5、BFC就是页面上的一个隔离的独立容器，容器里的子元素不会影响到外面的元素。反之亦如此。<br>6、计算BFC的高度时，浮动元素也参与计算。<br>1、独立渲染区域；<br>2、与这个区域外部毫不相关；<br>3、需要触发（需要写一行声明，来告诉外界声明独立）<br>  建议使用overflow：hidden来声明<br>  在包住的div里触发，要触发哪一个就在哪一个地方写上overfolw:hidden</p>
<p>####哪些元素会生产BFC？<br>1、根元素<br>2、float属性不为none<br>3、position为absolute或fixed<br>4、disply为inline-block，table-cell,table-caption,flex,inline-flex<br>5、overflow不为visible</p>
<p>###IFC 行内格式化上下文</p>
<p>解决垂直居中Vitical-align:middle，要配合line-height：数据，使用</p>
<p>Box一个接一个的水平排列，起点是包含块的顶部。水平方向上的margin、border和Padding在框之间得到保留。</p>
<p>框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中的文字的基线对齐。包含那些框的长方形区域，会形成一行，叫做行框。</p>
<p>一个行框的宽度由包含它的元素的宽度和包含它的元素里面有没有float元素来决定，高度的确定由行高度计算规则决定。</p>
<p>行高的高度足以包含它的内部容器，也可能比它包含的容器们都高（比如在基线对齐的时候），当它包含的内部容器的高度小于行框的高度时，内部容器的垂直位置由vertical属性来确定，这个性质可以用来实现垂直居中。</p>
<p>当几个行内框在水平方向无法放入一个行内框时，它们可以分配在两个或多个垂直堆叠的行框中。因此，一个段落就是行框在垂直方向上的堆叠。行框在堆叠时没有垂直方向上的分割且永不重叠。</p>
<p>一个行内框超出包含它的行框的宽度，它将会被分割为几个框。如果一个行框不能被分割，行内框会益处行框。</p>
<p>如果一个行内框被分割，margin、padding、border在所有分割处没有视觉效果。</p>
<p>创建一个IFC的环境，让行框的高度是包含块的高度的100%,让行框内部的元素使用Vertical-align：middle,</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/02/AJAX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xdd">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/AJAX/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-02T17:08:49+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>什么是Ajax<br>Ajax是用JavaScript执行异步网络请求，请求是异步执行的，也就是说，要通过回调函数获得响应。在现代浏览器上写AJAX主要依靠XMLHttpRequest对象：</p>
<p>‘use strict’;<br>function success(text) {<br>    var textarea = document.getElementById(‘test-response-text’);<br>    textarea.value = text;<br>}</p>
<p>function fail(code) {<br>    var textarea = document.getElementById(‘test-response-text’);<br>    textarea.value = ‘Error code: ‘ + code;<br>}</p>
<p>var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象</p>
<p>request.onreadystatechange = function () { // 状态发生变化时，函数被回调<br>    if (request.readyState === 4) { // 成功完成<br>        // 判断响应结果:<br>        if (request.status === 200) {<br>            // 成功，通过responseText拿到返回的数据</p>
<pre><code>        return success(request.responseText);
    } else {
        // 失败，根据响应码判断失败原因:
        return fail(request.status);
    }
} else {
    // HTTP请求还在继续...
}
</code></pre><p>}</p>
<p>// 发送请求:<br>request.open(‘GET’, ‘/api/categories’);<br>request.send();</p>
<p>alert(‘请求已发送，请等待响应…’);<br>详细过程：</p>
<p>创建XMLHttpRequest对象，也就是创建一个异步调用对象<br>创建一个新的HTTP请求，并指定请求方式、URL、是否异步调用<br>设置响应HTTP请求状态变化函数<br>发送HTTP请求<br>获取异步调用返回的函数<br>使用javascript和DOM实现局部刷新<br>1.创建XMLHttpRequest对象</p>
<p>//创建XMLHttpRequest对象<br>var xhr;<br>if(window.XMLHttpRequest){<br>    //for ie7+,firefox,Chrome,Opera,Safari<br>    xhr=new XMLHttpRequest();<br>}else{<br>    //for ie6,ie5<br>    xhr=new ActiveXObject(“Microsoft.XMLHTTP”);<br>}<br>2.向服务器发送请求</p>
<p>//向服务器发送请求<br>//open()规定发送请求的类型，url，是否异步处理<br>xhr.open(“GET”,”test.txt”,true);<br>xhr.send();<br>GET和POST,与POST相比，GET传输速度快，效率高，大部分情况下使用GET，在以下几种情况中使用POST：</p>
<p>无法使用缓存文件(更新服务器上的文件或数据)<br>向服务器发送大量数据 (POST没有数据量限制)<br>发送包含未知字符的用户输入时，POST比GET更稳定，可靠。<br>3.服务器响应</p>
<p>//如果来自服务器的响应不是XML文件，使用responseText属性<br>myDiv.innerHTML=xhr.responseText;</p>
<p>//如果来自服务器的响应是XML文件<br>xmlDoc=xhr.responseXML;<br>txt=””;<br>x=xmlDoc.getElementsByTagName(“ARTIST”);<br>var myDiv= document.getElementById(“myDiv”);<br>for (i=0;i&lt;x.length;i++){<br>  txt=txt + x[i].childNodes[0].nodeValue + “<br>“;<br> }<br>myDiv.innerHTML=txt;<br>4.readyState</p>
<p>//当readyState改变时，就会触发onreadystatechange事件<br>//readyState属性存有XMLHttpRequest对象的状态信息<br>//onreadystatechange事件会触发5次，对应readyStates的5个状态(0~4)<br>xhr.onreadystatechange==function(){<br>    if(xhr.readyState == 4 &amp;&amp; xhr.status ==200){<br>        myDiv.innerHTML=xhr.resopnseText;<br>    }<br>}</p>
<p>//或者使用Callback函数<br>function myFun(){<br>    loadXMLDoc(“test.txt”,function(){<br>        if(xhr.readyState==4 &amp;&amp; xhr.status ==200){<br>            myDiv.innerHTML=xhr.resopnseText;<br>        }<br>    });<br>}<br>XMLHttpRequest对象的三个重要属性：</p>
<p>onreadystatechange 存储函数，当readyState属性改变时就会调用该函数<br>readyState 存有XMLHttpRequest对象的状态</p>
<p>0 （未初始化）还没有调用open()方法</p>
<p>1 （载入）已调用send()方法，正在发送请求</p>
<p>2 （载入完成）send()方法完成，已收到全部相应内容</p>
<p>3 （解析）正在解析相应内容</p>
<p>4 （完成）相应内容解析完成，可以在客户端调用了</p>
<p>status</p>
<p>200 ‘ok’</p>
<p>404 未找到页面</p>
<p>优点</p>
<p>Ajax 最大的优点是无刷新数据读取：能在不刷新整个页面的前提下与服务器通信维护数据。更为迅捷地响应用户交互，避免了发送没有改变的信息，减少用户等待时间，带来非常好的用户体验；</p>
<p>异步与服务器通信：AJAX使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。优化了Browser和Server之间的沟通，减少不必要的数据传输、时间及降低网络上数据流量；</p>
<p>前端和后端负载平衡：把一些服务器负担的工作转嫁到客户端，用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。这种“按需取数据”的方式，可最大程度的减少冗余请求和对服务器造成的负担，提升站点性能；</p>
<p>界面与应用分离：Ajax使WEB中的界面与应用分离（也可以说是数据与呈现分离），有利于分工合作、减少非技术人员对页面的修改造成的WEB应用程序错误、提高效率、适用于现在的发布系统。</p>
<p>缺点</p>
<p>AJAX干掉了Back和History功能：动态更新的页面，用户无法回到前一个页面状态，因为浏览器仅能记忆历史记录中的静态页面。解决方案是使用URL片断标识符（通常被称为锚点，即URL中#后面的location. hash）来保持跟踪；</p>
<p>AJAX的安全问题：Ajax技术对企业数据建立了一个直接通道。会暴露比以前更多的数据和服务器逻辑。并会隐藏客户端的安全扫描技术，允许黑客从远端服务器上建立新的攻击。还有Ajax也难以避免跨站点脚步攻击、SQL注入攻击和基于Credentials的安全漏洞等等；</p>
<p>对搜索引擎支持较弱：对搜索引擎的支持比较弱。如果使用不当，AJAX会增大网络数据的流量，从而降低整个系统的性能。</p>
<p>违背URL和资源定位的初衷：你在一个URL地址下面看到的和我在这个URL地址下看到的内容是不同的。这个和资源定位的初衷是相背离的。</p>
<p>Ajax在JQ和JS中的区别</p>
<p>jquery是将原生的JS封装了的，不同浏览器对Ajax的实现可能不一样，jQuery解决了兼容问题，让我们用同一种方式调用；接口更清晰好用，比如jquery把jsonp（其实是通过script标签绕过同源策略）封装的就像一个普通的ajax请求。</p>
<p>Ajax修改获取header：<br>利用xmlHttp.setRequestHeader来设置request请求头：例如：xmlHttp.setRequestHeader(‘cache-control’,’no-cache’);</p>
<p>利用xmlHttp.getResponseHeader来获取response头信息;例如：xmlHttp.getResponseHeader(“Date”)；</p>
<p>另外 request.setCharacterEncoding(“UTF-8”)也可以设置发送到服务端数据编码格式（一般来说发送的编码格式跟服务端解析格式必须是一致的）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/02/作用域和闭包/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xdd">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/作用域和闭包/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-02T17:08:49+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>作用域<br>作用域是什么？其实作用域是针对变量的，一个变量在某个区域内起作用，这份区域就是他的作用域。顺便说一句，在 js中没有块级作用域（ES6除外），比如</p>
<p>if (true) {<br>    var name = “zhangsan”<br>}<br>console.log (name)      // “zhangsan”<br>学过java等高级语言的同学肯定会说这样写岂不是就报错了，但是在js中，这么写是完全ok的，因为js没有块级作用域，但实际上并不推荐这么写。</p>
<p>在js中，只有函数和全局作用域，比如</p>
<p>var a = 100<br>function fn () {<br>    var a = 200<br>    console.log (‘fn’,a)<br>}<br>console.log (‘global’,a)<br>fn()</p>
<p>作用域链<br>在这里我们讲一个概念：<br>自由变量，即当前作用域没有定义的变量。</p>
<p>比如</p>
<p>var a = 100<br>function fn () {<br>    var b = 200<br>    console.log (a)<br>    console.log (b)<br>}<br>fn ()<br>在console.log (a) 中的a就是自由变量，在当前作用域中并没有定义a，所以要去函数定义时的父级作用域中找。我们再来看一个稍微复杂一点点的例子</p>
<p>var a = 100<br>function fn () {<br>    var b = 200<br>    function fn1 () {<br>        var c = 300<br>        console.log (a)<br>        console.log (b)<br>        console.log (c)<br>    }<br>    fn1 ()<br>}<br>fn ()<br>在执行console.log (a) 时，由于当前作用域没有定义a，所以要去fn在定义时的父级作用域找，此时它的父级作用域是fn，fn中也没有定义a，所以再去fn在定义时的父级作用域（即全局作用域）中找，此时就能找到a。b，c也是同理。上述过程就形成了一条作用域链，简单来说作用域链就是自由变量的查找，子对象会一级一级地向上寻找所有父对象的变量。</p>
<p>闭包<br>专业说法：当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。（对内部函数的引用会添加到外部函数的活动对象上）</p>
<p>还可以这么理解：闭包就是一个具有封闭功能与包裹功能的结构，是为了实现具有私有访问空间的函数的，函数可以构成闭包，因为函数内部定义的数据函数外部无法访问，即函数具有封闭性；函数可以封装代码即具有包裹性，所以函数可以构成闭包。创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量。</p>
<p>而大家普遍认为的闭包是：</p>
<p>;(function fn() {})();</p>
<p>这只是闭包的一种形式而已，也就是闭包的一种应用，这样用闭包的好处是避免变量冲突和污染，能够自动执行；闭包前后最好都要写分号，因为防止多文件集成成一个文件后，高压缩出现语法错误。</p>
<p>闭包有3个特性：</p>
<p>1、函数嵌套函数</p>
<p>2、函数内部可以引用外部的参数和变量</p>
<p>function f1() {<br>   var n=999;<br>   function f2() {<br>       alert(n);    // 999<br>   }<br>}<br>f2被包在函数f1内部，f1内的所有局部变量，对f2都是可见的。反过来就不行，f2内的局部变量，对f1就是不可见的。</p>
<p>3、参数和变量不会被垃圾回收机制回收，让这些变量的值始终保持在内存中。</p>
<p>闭包有什么用，使用场景：</p>
<p>当我们需要在模块中定义一些变量，并希望这些变量一直保存在内存中但又不会“污染”全局的变量时，就可以用闭包来定义这个模块。</p>
<p>使用闭包的注意点：</p>
<p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。<br>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。<br>函数套函数就是闭包吗？<br>不是！当一个内部函数被其外部函数之外的变量引用时，才会形成了一个闭包。</p>
<p>经典面试题：创建10个a标签，点击时弹出相应的序号<br>在这里我给大家说两种方法，其中一种就是和我们这篇文章的知识点相关的方法</p>
<p>var i<br>for (var i = 0; i &lt; 10; i++) {<br>    (function (i) {<br>        var a = document.createElement(“a”)<br>        a.innerHTML = i + “<br>“<br>        a.addEventListener(“click”, function (e) {<br>            e.preventDefault()<br>            alert(i)<br>        })<br>        document.body.appendChild(a)<br>    })(i)<br>}<br>我们把参数 i 作为传给立即执行函数，这样，i的值就传给了立即执行函数的局部变量 i 了。立即执行函数会直接执行，但是其活动不会销毁，因为里面有个匿名函数。执行后局部变量 i 与全局变量i 联系就切断了，也就是执行的时候，传进去的变量i是多少，立即执行函数的局部变量 i 就是多少，并且该局部变量 i仍然没有消失，因为匿名函数的存在。</p>
<p>这时候，return中的匿名函数的作用域链中会有两个变量 i。当点击a的时候，它向上搜索 i 的时候，它找到立即执行函数的局部变量 i ，就停止向上查找了，因此最后的结果就不会是全局变量 i 的值10了。</p>
<p>还有一种方法是创建索引值</p>
<p>var i<br>for (var i = 0; i &lt; 10; i++) {<br>    var a = document.createElement(“a”)<br>    a.innerHTML = i + “<br>“<br>    a.index = i;<br>    a.addEventListener(“click”, function (e) {<br>        e.preventDefault()<br>        alert(this.index)<br>    })<br>    document.body.appendChild(a)<br>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/02/语义化和Doctype/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xdd">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/语义化和Doctype/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-02T17:08:49+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>语义化<br>去除或丢失样式的时候能让页面呈现清晰结构<br>有利于SEO：有利于爬虫抓取更多的有效信息，爬虫依赖于标签来确定上下文和各个关键字的权重<br>方便其他设备解析（屏幕阅读器，盲人阅读器，移动设备），有利于无障碍<br>方便团队开发维护代码，语义化更加具有可读性，遵循W3C标准，减少差异化<br>Doctype<br>声明位于稳当手部，告知浏览器以哪种模式解析文档<br>严格模式的排版以该浏览器支持的最高标准运行<br>在混杂模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器以防止站点无法工作<br>Doctype不存在或者不正确会导致文档以混杂模式呈现<br>HTML5为何只写&lt;!DOCTYPE HTML&gt;<br>html5不基于SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照他们应该的方式来运行）；<br>而html4.01基于SGML，所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型<br>文档类型定义是一套为了进行程序间的数据交换而建立的关于标记符的语法规则</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/02/关于this/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xdd">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/关于this/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-02T17:08:49+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>执行上下文<br>每一个函数都有自己的执行上下文EC（执行环境 execution context），并且每个执行上下文中都有它自己的变量对象VO（Variable object），用于存储执行上下文中的变量 、函数声明 、函数参数，这解释了js如何找到我们定义的函数和变量。并且函数是js中唯一一个能创建出作用域的，注意：for，if()else()不能创建作用域。看一段代码</p>
<p>console.log (a)       // undefined<br>var a = 10<br>此时打开控制台就会打印undefined，这是因为在代码还没执行之前，a会被提前声明，此时的代码可以理解为</p>
<p>var a<br>console.log (a)      // undefined<br>var a = 10<br>代码执行到console.log (a) 时a只声明了，并没有赋值，所以结果当然是undefined。再来看一段代码</p>
<p>fn (“zhangsan”,20)<br>function fn (name) {<br>    age = 20<br>    console.log (name,age)      // “zhangsan” 20<br>    var age<br>}<br>此时打印的结果就是“zhangsan”，20。我们可以将代码理解为</p>
<p>function fn (name) {<br>    var age<br>    age = 20<br>    console.log (name,age)        // “zhangsan” 20<br>}<br>fn (“zhangsan”,20)<br>一段或者一个函数都会生成执行上下文，针对一段会生成全局的执行上下文，在执行之前先将变量定义和函数声明提前，针对一个函数会生成一个函数执行上下文，在函数执行之前，将函数中的变量定义，函数声明，this，arguments拿出来。<br>要注意的是函数声明和函数表达式的区别，看代码</p>
<p>function fn () { }          // 函数的声明<br>var fn = function () { }    // 函数表达式<br>this<br>其实本质上来说，js里面的this是一个指向函数执行环境的指针<br>，this在哪个函数里面，就指向这个函数的context，this永远指向最后调用它的对象，并且this要在执行时才能确认值，定义时无法确认。 例如</p>
<p>var a = {<br>    name :  “A”,<br>    fn : function （） {<br>        console.log (this.name)<br>    }<br>}<br>a.fn()                          // this === a<br>a.fn.call ({name : “B”})        // this === {name : “B”}，<br>var fn1 = a.fn<br>fn1()                           // this === window<br>第一种情况，是a调用了fn()，所以此时的this为a；</p>
<p>第二种情况，使用call()，将this的值指定为了{name : “B”}；</p>
<p>第三种情况，把a.fn赋给了fn1，但是调用时却是window在调用，所以this === window</p>
<p>this其实有好几种使用场景，在这里我们主要介绍其中四种</p>
<p>作为构造函数执行</p>
<p>function  Foo (name,age) {<br>    this.name = name           // this === f<br>    this.age = age             // this === f<br>    //return  this<br>}<br>var f = new Foo (“zhangsan”,20)<br>在这里new操作符会改变函数this的指向问题，指向创建的对象f。</p>
<p>为什么this会指向f？</p>
<p>首先new关键字会创建一个空的对象，然后会自动调用一个函数apply方法，将this指向这个空对象，这样的话函数内部的this就会被这个空的对象替代。</p>
<p>若构造函数中返回this或返回值是基本类型（number、string、boolean、null、undefined）的值，则返回新实例对象；若返回值是引用类型的值，则实际返回值为这个引用类型。例如：</p>
<p>function Fn()<br>{<br>    this.user = ‘Jay’;<br>    return {};<br>}<br>var a = new Fn();<br>console.log(a.user);     //undefined</p>
<p>function Fn()<br>{<br>    this.user = ‘Jay’;<br>    return function () {};<br>}<br>var a = new Fn;<br>console.log(a.user);    //undefined</p>
<p>function Fn()<br>{<br>    this.user = ‘Jay’;<br>    return 1;<br>}<br>var a = new Fn();<br>console.log(a.user);    // Jay<br>还有一点就是虽然null也是对象，但是在这里this还是指向那个函数的实例，因为null比较特殊。</p>
<p>function Fn()<br>{<br>    this.user = ‘Jay’;<br>    return null;<br>}<br>var a = new Fn;<br>console.log(a.user);          // Jay<br>知识点补充：在严格版中的默认的this不再是window，而是undefined</p>
<p>作为普通函数执行<br>function  fn () {<br>   console.log (this)       // this === window<br>}<br>fn ()<br>作为对象属性执行<br>var obj = {<br>    name : “A”,<br>    printName : function () {<br>        console.log (this.name)        // this === obj<br>    }<br>}<br>obj.printName ()<br>call()、apply()、bind()<br>这三种方法都可以改变函数体内部this的指向，但是又存在一些差异。下面，我们看一个例子让你完全搞懂这三个方法的异同点。</p>
<p>var name  = “小明” , age = “17”<br>var obj = {<br>    name : “安妮”,<br>    objAge ：this.age,<br>    fun : function () {<br>        console.log ( this.name + “今年” + this.age )<br>    }<br>}<br>console.log(obj.objAge)          // 17<br>obj.fun()                        // 安妮今年undefined<br>出现这样的结果是因为，在obj.objAge中，this的指向是obj，但是这句话外部没有函数包着，所以这里的执行环境是全局的；在obj.fun()中，this的指向也是obj，但是obj中没有定义age，所以是undefined。再来看第二个例子：</p>
<p>var name1  = “Jay”<br>function show () {<br>    console.log (this.name1)<br>}<br>show()         // Jay<br>这个很明显this指向的是window，所以打印的结果就是Jay。<br>下面我们分别用这三个方法重新定义this，看看是什么结果</p>
<p>var name  = “小明” , age = “17”<br>var obj = {<br>    name : “安妮”,<br>    objAge ：this.age,<br>    fun : function () {<br>        console.log ( this.name + “今年” + this.age )<br>    }<br>}</p>
<p>var a = {<br>    name : “Jay”,<br>    age : 23<br>}</p>
<p>obj.fun.call(a)              // Jay今年23<br>obj.fun.apply(a)             // Jay今年23<br>obj.fun.bind(a)()            // Jay今年23<br>我们会发现这三个方法的结果都一致，只有bind返回的是一个新的函数，你必须调用它才会被执行。<br>再来对比一下传参的情况：</p>
<p>var name  = “小明” , age = “17”<br>var obj = {<br>  name : “安妮”,<br>  objAge ：this.age,<br>  fun : function (like,dislike) {<br>    console.log (this.name + “今年” + this.age ，”喜欢吃” + like + “不喜欢吃” + dislike)<br>  }<br>}</p>
<p>var a = {<br>    name : “Jay”,<br>    age : 23<br>}</p>
<p>obj.fun.call(a,”苹果”,”香蕉”)              // Jay今年23 喜欢吃苹果不喜欢吃香蕉<br>obj.fun.apply(a,[“苹果”,”香蕉”])           // Jay今年23 喜欢吃苹果不喜欢吃香蕉<br>obj.fun.bind(a,”苹果”,”香蕉”)()            // Jay今年23 喜欢吃苹果不喜欢吃香蕉<br>call，bind，apply 这三个函数的第一个参数都是 this 的指向对象，注意如果call和apply的第一个参数写的是null，那么this指向的是window对象；</p>
<p>第二个参数有区别：</p>
<p>① call的参数是直接放进去的，用逗号分隔；</p>
<p>② apply的所有参数都必须放在一个数组里面传进去；</p>
<p>③ bind除了返回是函数以外，它的参数和call一样。当然，三者的参数不限定是string类型，允许是各种类型，包括函数 、 object 等等。</p>
<p>call和apply都是改变上下文中的this并立即执行这个函数，bind方法可以让对应的函数想什么时候调就什么时候调用，并且可以将参数在执行的时候添加。</p>
<p>在非严格模式下，call和apply的第一个参数如果指定为null或undefined时，会自动指向全局对象。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/02/web安全/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xdd">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/web安全/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-02T17:08:49+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>XSS<br>攻击者往页面里插入恶意HTML标签或者JS代码，窃取cookie中的用户私密信息；或者攻击者在论坛加一个恶意表单。</p>
<p>防范</p>
<p>对用户输入的地方检查长度对相关的标签字符予以过滤<br>任何内容写到页面之前都必须加以encode，避免标签泄露<br>避免直接在cookie中泄露用户隐私，例如email，密码<br>尽量采用POST而非GET提交表单<br>CSRF<br>基本步骤:<br>登录受信任网站A，并在本地生成Cookie，在不登出A的情况下，访问受害网站B</p>
<p>攻击类型：</p>
<p>使用Get更新请求资源，容易在危险网站B使用标签进行攻击<br>前端使用Post请求更新资源，而后端$_REQUEST去获取请求的数据，既可以获取GET请求，也可以获取POST请求的数据，这就造成了在后台处理程序无法区分这到底是GET请求的数据还是POST请求的数据<br>前端使用Post请求更新资源，后端也只接受获取post请求的数据，但是危险网站B通过iframe等手段同样造成攻击<br>防范手段：</p>
<p>验证码：每次的用户提交都需要用户在表单中填写一个图片上的随机字符串，易用性差<br>添加隐藏输入框：包含token，服务端验证是否匹配<br>服务端验证HTTP Referer字段：Http请求的来源地址不是业务域名，直接过滤掉请求<br>SQL注入<br>通过把sql命令插入到web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的sql命令</p>
<p>防范：</p>
<p>对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和&lt;&gt;进行转换等<br>永远不要使用动态拼装SQL，可以使用参数化的sql或者直接使用存储过程进行数据查询存取<br>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接<br>不要把机密信息明文存放，加密或者hash掉密码和敏感的信息<br>CSP<br>被设计为一个完整的框架来防御XSS和CSRF攻击，旨在减少XSS</p>
<p>CSP是一种由开发者定义的安全性政策性申明，通过CSP所约束的规则制定可信的内容来源（脚本，图片，iframe，fton，style等可能远程的资源）。通过CSP协定，让web处于一个安全的运行环境中</p>
<p>实例：</p>
<p>Content-Security-Policy:default-src”self”<br>只允许本站资源<br>Content-Security-Policy:default-src”self”;img-src*;script-src <a href="http://trustedscripts.example.com" target="_blank" rel="noopener">http://trustedscripts.example.com</a><br>只允许本站的资源及任意位置的图片以及指定网址下的脚本。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/02/react组件编写规范/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xdd">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/react组件编写规范/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-02T17:08:49+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>组件的私有方法都用 _ 开头，所有事件监听的方法都用 handle 开头。把事件监听方法传给组件的时候，属性名用 on 开头。例如：</p>
<commentinput onsubmit="{this.handleSubmitComment.bind(this)}">

<p>这样统一规范处理事件命名会给我们带来语义化组件的好处，监听（on）CommentInput 的 Submit 事件，并且交给 this 去处理（handle）。这种规范在多人协作的时候也会非常方便。</p>
<p>另外，组件的内容编写顺序如下：</p>
<p>static 开头的类属性，如 defaultProps、propTypes。<br>构造函数，constructor。<br>getter/setter（还不了解的同学可以暂时忽略）。<br>组件生命周期。<br>_ 开头的私有方法。<br>事件监听方法，handle<em>。<br>render</em>开头的方法，有时候 render() 方法里面的内容会分开到不同函数里面进行，这些函数都以render*开头。<br>render() 方法。</p>
</commentinput>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/02/React的state/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xdd">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/React的state/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-02T17:08:49+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>React 的核心思想是组件化的思想，应用由组件搭建而成，State是一个组件渲染时的数据依据。<br>一. 定义State<br>组件的任何UI改变，都可以从State的变化中反映出来；同时，State中的所有状态都是用于反映组件UI的变化，没有任何多余的状态，也不需要通过其他状态计算而来的中间状态。</p>
<p>组件中用到的一个变量是不是应该作为组件State，可以通过下面的4条依据进行判断：</p>
<p>这个变量是否是通过Props从父组件中获取？如果是，那么它不是一个状态。<br>这个变量是否在组件的整个生命周期中都保持不变？如果是，那么它不是一个状态。<br>这个变量是否可以通过其他状态（State）或者属性(Props)计算得到？如果是，那么它不是一个状态。<br>这个变量是否在组件的render方法中使用？如果不是，那么它不是一个状态。这种情况下，这个变量更适合定义为组件的一个普通属性，例如组件中用到的定时器，就应该直接定义为this.timer，而不是this.state.timer。<br>不是组件中用到的所有变量都是组件的状态！当存在多个组件共同依赖一个状态时，一般的做法是状态上移，将这个状态放到这几个组件的公共父组件中。</p>
<p>二. State 与 Props 区别<br>除了State, 组件的Props也是和组件的UI有关的。<br>他们之间的主要区别是：<br>State是可变的，是组件内部维护的一组用于反映组件UI变化的状态集合；<br>而Props对于使用它的组件来说，是只读的，要想修改Props，只能通过该组件的父组件修改。在组件状态上移的场景中，父组件正是通过子组件的Props, 传递给子组件其所需要的状态。</p>
<p>三. 如何正确修改State<br>不能直接修改State。</p>
<p>直接修改state，组件并不会重新重发render。例如：</p>
<p>// 错误<br>this.state.title = ‘React’;<br>正确的修改方式是使用setState():</p>
<p>// 正确<br>this.setState({title: ‘React’});<br>State 的更新是异步的。</p>
<p>调用setState，组件的state并不会立即改变，setState只是把要修改的状态放入一个队列中，React会优化真正的执行时机，并且React会出于性能原因，可能会将多次setState的状态修改合并成一次状态修改。所以不要依赖当前的State，计算下个State。当真正执行状态修改时，依赖的this.state并不能保证是最新的State，因为React会把多次State的修改合并成一次，这时，this.state将还是这几次State修改前的State。另外需要注意的事，同样不能依赖当前的Props计算下个状态，因为Props一般也是从父组件的State中获取，依然无法确定在组件状态更新时的值。</p>
<p>举个例子，对于一个电商类应用，在我们的购物车中，当我们点击一次购买数量按钮，购买的数量就会加1，如果我们连续点击了两次按钮，就会连续调用两次this.setState({quantity: this.state.quantity + 1})，在React合并多次修改为一次的情况下，相当于等价执行了如下代码：</p>
<p>Object.assign(<br>  previousState,<br>  {quantity: this.state.quantity + 1},<br>  {quantity: this.state.quantity + 1}<br>)<br>于是乎，后面的操作覆盖掉了前面的操作，最终购买的数量只增加了1个。</p>
<p>如果你真的有这样的需求，可以使用另一个接收一个函数作为参数的setState，这个函数有两个参数，第一个是当前最新状态（本次组件状态修改后的状态）的前一个状态preState（本次组件状态修改前的状态），第二个参数是当前最新的属性props。如下所示：</p>
<p>// 正确<br>this.setState((preState, props) =&gt; ({<br>  counter: preState.quantity + 1;<br>}))<br>State 的更新是一个浅合并（Shallow Merge）的过程。</p>
<p>当调用setState修改组件状态时，只需要传入发生改变的State，而不是组件完整的State，因为组件State的更新是一个浅合并（Shallow Merge）的过程。</p>
<p>四. State与Immutable<br>React官方建议把State当作是不可变对象，一方面是如果直接修改this.state，组件并不会重新render；另一方面State中包含的所有状态都应该是不可变对象。当State中的某个状态发生变化，我们应该重新创建这个状态对象，而不是直接修改原来的状态。那么，当状态发生变化时，如何创建新的状态呢？根据状态的类型，可以分成三种情况：</p>
<p>状态的类型是不可变类型（数字，字符串，布尔值，null， undefined）<br>这种情况最简单，因为状态是不可变类型，直接给要修改的状态赋一个新值即可。如要修改count（数字类型）、title（字符串类型）、success（布尔类型）三个状态：</p>
<p>this.setState({<br>  count: 1,<br>  title: ‘Redux’,<br>  success: true<br>})<br>状态的类型是数组<br>如有一个数组类型的状态books，当向books中增加一本书时，使用数组的concat方法或ES6的数组扩展语法（spread syntax）：</p>
<p>// 方法一：将state先赋值给另外的变量，然后使用concat创建新数组</p>
<p>var books = this.state.books;<br>this.setState({<br>  books: books.concat([‘React Guide’]);<br>})<br>// 方法二：使用preState、concat创建新数组</p>
<p>this.setState(preState =&gt; ({<br>  books: preState.books.concat([‘React Guide’]);<br>}))<br>// 方法三：ES6 spread syntax</p>
<p>this.setState(preState =&gt; ({<br>  books: […preState.books, ‘React Guide’];<br>}))<br>当从books中截取部分元素作为新状态时，使用数组的slice方法：</p>
<p>// 方法一：将state先赋值给另外的变量，然后使用slice创建新数组</p>
<p>var books = this.state.books;<br>this.setState({<br>  books: books.slice(1,3);<br>})<br>// 方法二：使用preState、slice创建新数组</p>
<p>this.setState(preState =&gt; ({<br>  books: preState.books.slice(1,3);<br>}))<br>当从books中过滤部分元素后，作为新状态时，使用数组的filter方法：</p>
<p>// 方法一：将state先赋值给另外的变量，然后使用filter创建新数组</p>
<p>var books = this.state.books;<br>this.setState({<br>  books: books.filter(item =&gt; {<br>    return item != ‘React’;<br>  });<br>})<br>// 方法二：使用preState、filter创建新数组</p>
<p>this.setState(preState =&gt; ({<br>  books: preState.books.filter(item =&gt; {<br>    return item != ‘React’;<br>  });<br>}))<br>注意不要使用push、pop、shift、unshift、splice等方法修改数组类型的状态，因为这些方法都是在原数组的基础上修改，而concat、slice、filter会返回一个新的数组。</p>
<p>状态的类型是普通对象（不包含字符串、数组）<br>3.1 使用ES6 的Object.assgin方法<br>// 方法一：将state先赋值给另外的变量，然后使用Object.assign创建新对象</p>
<p>var owner = this.state.owner;<br>this.setState({<br>  owner: Object.assign({}, owner, {name: ‘Jason’});<br>})<br>// 方法二：使用preState、Object.assign创建新对象</p>
<p>this.setState(preState =&gt; ({<br>  owner: Object.assign({}, preState.owner, {name: ‘Jason’});<br>}))<br>3.2 使用对象扩展语法（object spread properties）</p>
<p>// 方法一：将state先赋值给另外的变量，然后使用对象扩展语法创建新对象</p>
<p>var owner = this.state.owner;<br>this.setState({<br>  owner: {…owner, name: ‘Jason’};<br>})<br>// 方法二：使用preState、对象扩展语法创建新对象</p>
<p>this.setState(preState =&gt; ({<br>  owner: {…preState.owner, name: ‘Jason’};<br>}))<br>总结一下，创建新的状态对象的关键是，避免使用会直接修改原对象的方法，而是使用可以返回一个新对象的方法。当然，也可以使用一些Immutable的JS库，如Immutable.js，实现类似的效果。</p>
<p>那么，为什么React推荐组件的状态是不可变对象呢？</p>
<p>一方面是因为不可变对象方便管理和调试；</p>
<p>另一方面是出于性能考虑，当对象组件状态都是不可变对象时，我们在组件的shouldComponentUpdate方法中，仅需要比较状态的引用就可以判断状态是否真的改变，从而避免不必要的render调用。当我们使用React 提供的PureComponent时，更是要保证组件状态是不可变对象，否则在组件的shouldComponentUpdate方法中，状态比较就可能出现错误，因为PureComponent执行的是浅比较（比较对象的引用）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/02/React diff算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xdd">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/React diff算法/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-02T17:08:49+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>React有两大提高性能的神奇特色：虚拟DOM &amp; diff算法。React diff作为Virtual DOM的加速器，其算法的改进优化是React整的界面渲染的基础，以及性能提高的保障。</p>
<p>React diff表示什么？表示React针对传统的diff算法进行了React风格的优化！</p>
<p>传统diff算法<br>计算一棵树形结构转换成另一棵树形结构的最少操作，是一个复杂且值得研究的问题。</p>
<p>传统 diff 算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，其中 n 是树中节点的总数。O(n^3) 到底有多可怕，这意味着如果要展示1000个节点，就要依次执行上十亿次的比较。代价太高。</p>
<p>如果 React 只是单纯的引入 diff 算法而没有任何的优化改进，那么其效率是远远无法满足前端渲染所要求的性能。</p>
<p>React diff优化<br>传统的diff算法的复杂度为O(n^3),显然无法满足性能要求。Facebook工程师通过大胆的策略，将O(n^3)复杂度简化成了O(n)</p>
<p>diff策略</p>
<p>Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。<br>拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。<br>对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。</p>
<p>基于以上三个前提策略，React团队对传统diff算法优化</p>
<p>a-&gt;tree diff</p>
<p>b-&gt;component diff<br>c-&gt;element diffd</p>
<p>优化策略a: tree diff</p>
<p>基于tree diff策略，React对Virtual DOM树进行 分层比较、层级控制，只对相同颜色框内的节点进行比较(同一父节点的全部子节点)，当发现某一子节点不在了直接删除该节点以及其所有子节点，不会用于进一步的比较，在算法层面上就是说只需要遍历一次就可以了，而无需在进行不必要的比较，便能完成整个DOM树的比较。<br>如图：</p>
<p>同属于分层比较、层级控制范畴，还会出现DOM节点跨层级的移动操作(React中这种情况DOM节点不稳定，损害性能，所以开发中不推荐这种情况的出现)，React diff怎么解决的呢？如下图情况：</p>
<p>上面描述的是同一层次不同DOM节点范畴，React diff用趋近于‘暴力’的方式，并不是把A B C 直接拼接到 D 节点上，而是删除A B C 三个节点之后在 D 下面在创建的 A B C。这里不做详细分析，想直观理解该过程，建议阅读这篇用在生命周期里打log的方式展示上述过程</p>
<p>优化策略b: component diff</p>
<p>React是基于组件构建应用的，对于组件间的比较所采用的策略也是简洁高效。</p>
<p>对于同一类型的组件，根据Virtual DOM是否变化也分两种，可以用shouldComponentUpdate()判断Virtual DOM是否发生了变化，若没有变化就不需要在进行diff，这样可以节省大量时间，若变化了，就对相关节点进行update<br>对于非同一类的组件，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。</p>
<p>如下图，当 component D 改变为 component G 时，即使这两个 component 结构相似，一旦 React 判断 D 和 G 是不同类型的组件，就不会比较二者的结构，而是直接删除 component D，重新创建 component G 以及其子节点。虽然当两个 component 是不同类型但结构相似时，React diff 会影响性能，但正如 React 官方博客所言：不同类型的 component 是很少存在相似 DOM tree 的机会，因此这种极端因素很难在实现开发过程中造成重大影响的。</p>
<p>而如果上图中左一中的D节点只是单纯的改变什么state，update就好了。</p>
<p>优化策略c: element diff</p>
<p>所有同一层级的子节点.他们都可以通过key来区分—–并遵循策略a、b。</p>
<p>没经过优化的算法，实现新老交替的方法是将A B C D全部删除之后，在新建B A D C，这样的实现方法显然很垃圾，React diff怎么优化呢？是通过为每一个节点添加key值标识。</p>
<p>新老集合所包含的节点，如上图所示，新老集合进行 diff 差异化对比，通过 key 发现新老集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将老集合中节点的位置进行移动，更新为新集合中节点的位置，此时 React 给出的 diff 结果为：B、D 不做任何操作，A、C 进行移动操作，即可。</p>
<p>上述分析的是新老集合中存在相同节点但是位置不同，要是有新加入的节点且有旧节点需要删除呢？这里不再啰嗦，如下图：</p>
<p>加了key的好处：</p>
<p>如果不加key，map遍历的时候控制台发出warn，既然是warn就说明不加也能实现遍历，但是是经过删除、创建、插入实现，这样的话损害性能可想而知，而加上key就可以有助于React diff算法结合Virtual DOM找到最合适的方式进行diff，最大限度的实现高效diff，即哪里需要改变，就改变哪里！</p>
<p>总结<br>React 通过分层求异的策略，对 tree diff 进行算法优化；<br>React 通过相同类生成相似树形结构，不同类生成不同树形结构的策略，对 component diff 进行算法优化；<br>React 通过设置唯一 key的策略，对 element diff 进行算法优化；<br>React 通过制定大胆的 diff 策略，将 O(n3) 复杂度的问题转换成 O(n) 复杂度的问题；<br>建议，开发时保持稳定的DOM结构有助于性能的提升；</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/02/position属性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xdd">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/position属性/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-02T17:08:49+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>position 是 CSS 中非常重要的一个属性，通过 position 属性，我们可以让元素相对于其正常位置，父元素或者浏览器窗口进行偏移。<br>postion 属性有 4 个不同类型的定位，这些类型会影响元素的生成方式，下面我们详细说明 position 属性。</p>
<ol>
<li>static（静态）</li>
</ol>
<p>static 是 position 属性的默认值，默认情况下，块级元素和行内元素按照各自的特性进行显示。这种定位不会受到 top,bottom,left,right 的影响，不能通过 z-index 进行层次分级。</p>
<ol start="2">
<li>fixed（固定定位）</li>
</ol>
<p>fixed 定位是指元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的他也不会滚动，且 fixed 定位使元素的位置与文档流无关，因此不占据空间，且他会和其他元素发生重叠。</p>
<ol start="3">
<li>relative（相对定位）</li>
</ol>
<p>相对定位元素的定位是相对于他自己的正常位置的定位。对象不可以层叠，不可以脱离文档流，参考自身静态位置，通过 top,bottom,left,right 定位，并且可以通过 z-index 进行层次分级。</p>
<ol start="4">
<li>absolute（绝对定位）</li>
</ol>
<p>脱离文档流，通过 top，bottom，left，right 定位。选取其最后一个有定位设置的父级对象进行绝对定位，如果对象的父级没有设置定位属性，absolute 元素将以 body 坐标原点进行定位，可以通过 z-index 进行层次分级。</p>
<ol start="5">
<li>inherit（继承）</li>
</ol>
<p>规定应该从父元素继承 position 属性的值。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">xdd</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xdd</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
